
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Fitch Autocomplete</title>
    <script src="g.js"></script>
    <script src="nearley.js"></script>
    <script src="content.js"></script>
    <style>
        body {
            margin: 0;
        }

        body, button, .button {
            font-family: 'Roboto';
        }

        header h1 {
            padding-left: 1em;
        }

        #in {
            padding: 0.5em;
            border: 1px solid;
            font-family: monospace;
            font-size: 12pt;
        }

        #out {
            padding: 0.5em;
            border: 1px solid black;
            width: 100%;
            font-family: monospace;
        }

        #out_nums {

        }

        #out_nodes {

        }

        #out_just {
            margin-left: 0.7em;
        }

        #out_lat {
            border: 1px solid black;
            width: 100%;
            height: 10vh;
        }

        #inout {
            display: flex;
            width: 100%;
            font-size: 12pt;
        }

        @media screen and (min-width: 800px) {
            #in {
                width: 400px;
            }
        }

        @media screen and (max-width: 800px) {
            #inout {
                flex-direction: column-reverse;
            }

            #in {
                width: 100%;
            }

        }

        navigation {
            margin: 0;
            background: #7a6490;
            display: flex;
        }

        navigation, section {
            padding: 10px;
        }

        section * {
            box-sizing: border-box;
        }

        .button {
            font-size: 11pt;

            display: inline-flex;
            align-items: center;

            box-sizing: border-box;

            background: #fafafa;
            border: 1px solid #451d84;
            /* color: white; */
            color: #111;
            border-radius: 3px;
            text-decoration: none;
            padding: 6px;
            cursor: default;
            box-shadow: 0 0 1px black;
        }

        .button option {
            background: white;
        }

        .button + .button {
            margin-left: 0.5em;
        }

        .button:hover {
            background: #e6e2ec;
        }

        #status {
            display: inline-block;
            margin-left: 0.3em;

            width: 1em;
            height: 1em;

            border: 1px solid #666;
            display: inline-block;
            background-color: rgb(87, 158, 77);
        }

        .modal {
            position: absolute;
            box-sizing: border-box;
            overflow-y: auto;

            z-index: 1;

            width: 70%;
            margin-left: 15%;
            margin-top: 10vh;
            height: 80vh;

            background: rgba(240, 234, 251, 0.95);
            border: 1px solid #341aa7;
            border-radius: 4px;
            box-shadow: 0px 0px 5px black;

            text-align: justify;

            display: none;
        }

        .modal h2 {
            margin: 0;
            padding: 1em;
            background: rgb(202, 190, 247);
        }

        .modalcontent {
            padding: 2em;
            padding-left: 3em;
            margin: 0;
        }

        .modalcontent td {
            width: 3em;
            border: 1px solid gray;
            text-align: center;
        }


        .modalcontent td:first-child {
            text-align: left;
        }

        .modalcontent td:nth-child(2) {
            font-weight: bold;
        }

        .modalblock {
            /*width: 48%;*/
        }



        .branch {
            border-left: 1px solid black;
            margin-left: 1em;
            width: fit-content;
        }
    </style>
</head>
<body>

<div class="overlay" style="position: absolute; width: 100vw; height: 97vh; margin: 0; padding: 0; display: none;" onclick="help_close()"></div>
<div class="modal">
    <h2>Conventions</h2>
    <div class="modalcontent">
        <div class="modalblock">
            <h3>About</h3>
            <p>
                This tool autocompletes justifications within the given first-order natural deduction.
            </p>
            <p>
                This tool does not...
            </p>
            <ul>
                <li>
                    automatically find proofs or insert helpful formulas;
                </li>
                <li>
                    verify whether deductions are correct [but can be used for this purpose in most cases];
                </li>
                <li>
                    enable you to input or verify your own justifications [but it does list all candidates for justifications, if you're using the same conventions].
                </li>
            </ul>
            <p>
                In short, this tool enables you to write down <b>your</b> (valid) deductions quickly.
                Everything else mentioned is mostly doable, but there are other tools for those purposes.
            </p>
        </div>
        <!-- <div class="modalblock">
            <h3>Proofs vs. derivations</h3>
            <p>
                Deductions with at least one initial assumption are "derivations". Everything else is a "proof".
                Differentianing these is needed here, because this tool is intended to be used  process deductions line-by-line.
                <b>Proofs should be started with a single tilde symbol (~) in the first line.</b>
            </p>
        </div> -->
        <div class="modalblock">
            <h3>Syntax</h3>
            <p>
                The following connectives and quantifiers are available:
            </p>
            <table>
                <tr>
                    <td></td><td>Symbol</td><td colspan="6">In text</td>
                </tr>
                <tr>
                    <td>Logical NOT</td><td>¬</td><td>~</td><td>~</td><td>-</td><td></td><td></td><td></td>
                </tr>
                <tr>
                    <td>Logical AND</td><td>∧</td><td>/\</td><td>&</td><td>&&</td><td>*</td><td>.</td><td></td>
                </tr>
                <tr>
                    <td>Logical OR</td><td>∨</td><td>\/</td><td>\/</td><td>+</td><td>|</td><td>||</td><td>,</td>
                </tr>
                <tr>
                    <td>Conditional</td><td>→</td><td>-></td><td>&gt;</td><td>=&gt;</td><td></td><td></td><td></td>
                </tr>
                <tr>
                    <td>Biconditional</td><td>↔</td><td><-></td><td>=</td><td>&lt;&gt;</td><td>&lt;=&gt;</td><td></td><td></td>
                </tr>
                <tr>
                    <td>Falsum</td><td>⊥</td><td>#</td><td>_|_</td><td></td><td></td><td></td><td></td>
                </tr>
                <tr>
                    <td>Universal quantifier</td><td>∀</td><td>A</td><td>@</td><td></td><td></td><td></td><td></td>
                </tr>
                <tr>
                    <td>Existential quantifier</td><td>∃</td><td>E</td><td></td><td></td><td></td><td></td><td></td>
                </tr>
                <tr>
                    <td>Relation</td><td>A&mdash;Z</td><td>A&mdash;Z</td><td></td><td></td><td></td><td></td><td></td>
                </tr>
                <tr>
                    <td title="Important: see conventions below">Variable/Constant</td><td>a&mdash;z</td><td>a&mdash;z</td><td></td><td></td><td></td><td></td><td></td>
                </tr>
            </table>
            <p>

                Deduction is a list of lines, where each line is a block of <b>|</b>'s followed by a formula.
                If A is an asummption, use L instead of the rightmost |.
                For example: <br/>
                <span style="padding-left: 1em; display: inline-block">
                    L ¬¬A <br/>
                    | A
                </span>
            </p>
        </div>
        <div class="modalblock">
            <h3>Conventions</h3>
            <p>
                Note that relational symbols (including propositions) are limited in length to one character.
                Letters 'A' and 'E' can be used for propositions (0-ary relations), but it might be confusing.
                However, this tool will correctly detemine whether Ax
                    is universal quantification or an atomic formula, assuming there are no typos in the starting formula.
            </p>
            <p>
                You should put brackets everywhere, except when it doesn't matter.
            </p>
            <p>

                Conventions for quantifiers:
            </p>
            <ul>
                <li>The main restriction is that you <b>do not use the same letters for variables and (pseudo)constants.</b>
                    For example, a valid proof of ∀x P(x) from the assumption ∀x ¬¬P(x) would go as follows:
                    ∀x ¬¬P(x); ¬¬P(c); P(c); ∀x P(x).
                    This restriction is not enforced (not abiding it will not cause a syntax error).
                    For example, if you have Pt ∧ Px, you can deduce ∃x (Px ∧ Px).
                    However, if you have Px ∧ Pt, since you are trying to introduce x, and the first occurence of x in
                        the original formula Px ∧ Pt is Px, the second occurence of Px would cause an error (it differs from Pt).
                    A good way to solve this would be to explicitly ask the user what term is being replaced in order to find a justification,
                        but this is exactly what we're trying to avoid.
                </li>
                <li>Introducing ∀, specifically ∀x F(x), can be done given a formula F such that F is exactly like F(x),
                    except that all free occurences of some letter t (which may or may not actually appear in F) within F
                    are replaced with x.
                    There are the usual restrictions:
                    <ul>
                        <li>t should not be mentioned in any assumption, unless it belongs to an already completed subproof</li>
                        <li>F should not contain a quantifier over t whose scope contains x an occurence of x (e.g. EtQx)</li>
                    </ul>
                </li>
                <li>
                    Introducing ∃, specifically ∃x F(x), can be done given a formula F such that F is exactly like F(x),
                    except that all zero or more occurences of some letter t (which may or may not actually appear in F) within F
                    are replaced with x.
                    There are the usual restrictions:
                    <ul>
                        <li>F should not contain a quantifier over t whose scope contains an occurence of x (e.g. EtQx)</li>
                    </ul>
                </li>
                <li>Eliminating ∀, specifically ∀x F(x), is done by inserting any formula F such that
                    all free occurences of x (which may or may not actually appear in F(x)) within F
                    are replaced with t.
                    There are the usual restrictions:
                    <ul>
                        <li>F should not contain a quantifier over t whose scope contains x an occurence of x (e.g. EtQx)</li>
                    </ul>
                </li>
                <li>Eliminating ∃, specifically ∃x F(x), is done by inserting a subproof beginning with a formula F such that
                    all free occurences of some letter t (which may or may not actually appear in F) within F
                    are replaced with x.
                    The subproof should and with a formula not containing an occurence of t.
                    There are the usual restrictions:
                    <ul>
                        <li>t should not be mentioned in any preceding line, unless it belongs to an already completed subproof</li>
                        <li>F should not contain a quantifier over t whose scope contains x an occurence of x (e.g. EtQx)</li>
                    </ul>
                </li>
            </ul>
            <p>
                Rules for logical connectives are mostly standard.
                There are some additional conventions regarding justifications that probably won't matter such as:
            </p>
            <ul>
                <li>when introducing ∧ from lines numbered a, b; the order will be a, b if a < b, otherwise b, a</li>
                <li>when eliminating → from lines a: F → G, b: F; the order will be a, b regardless of whether a < b</li>
                <li>when introducting ⊥ from a: X, b: ¬X; the order will be a, b</li>
                <li>similarly for other connectives</li>
            </ul>
            </p>
        </div>
        <div class="modalblock">
            <h3>Author</h3>
            <div>Luka Mikec, nameDOTsurnameATgmailDOTcom, and insert 1 before AT</div>
        </div>
    </div>
</div>

<header>
    <h1>
        fitch-justify
    </h1>
</header>
<navigation>
    <div class="button" title="Green: valid syntax & justifications found for all lines. Blue: valid syntax & missing justifications. Yellow: otherwise. ">
        Status: <div id="status" style=""></div>
    </div>

    <div style="    flex-grow: 1 !important;">

    </div>

    <select class="button" id="examples" oninput="example_click()" >
        <option value="contrapos" selected>Example: Contraposition</option>
        <option value="demorgan1">Example: De Morgan 1</option>
        <option value="demorgan2">Example: De Morgan 2</option>
        <option value="drinker">Example: Drinker</option>
    </select>

    <a class="button" onclick="help_click()" >
        Help
    </a>
    <a class="button" href="https://github.com/luka-mikec/fitch-justify">
        Git repository
    </a>

    <select class="button" id="lang" oninput="lang_click()" >
        <option value="en" selected>English</option>
        <option value="hr">Croatian</option>
    </select>
</navigation>
<section>
    <div style="" id="inout">
            <textarea id="in" rows="35" style="" oninput="try_compile()">
            </textarea>
        <div id="out">


            <div style="display: flex;" >
                <div id="out_nums" style=""></div>
                <div id="out_nodes" style=""></div>
                <div id="out_just" style=""></div>
            </div>
        </div>
    </div>
    <textarea id="out_lat" style="">b</textarea>
    <div id="out_dbg" style="display: none;">c</div>
</section>

<script>
    function help_click()
    {
        document.querySelector('.modal').style.display = 'block';
        document.querySelector('.overlay').style.display = 'block';
    }
    function help_close()
    {
        document.querySelector('.modal').style.display = 'none';
        document.querySelector('.overlay').style.display = 'none';
    }
    function lang_click()
    {
        window.clang = window[document.querySelector('#lang').value];
        try_compile();
    }
    //document.body.addEventListener('click', () => { document.querySelector('.modal').style.display = 'none'; } , true);


    function wip_state()
    {
        status_div.style.backgroundColor = 'rgb(55,99,200)';
    }

    function ok_state()
    {
        status_div.style.backgroundColor = '#4CAF50';
    }

    function error_state()
    {
        status_div.style.backgroundColor = 'rgb(255, 213, 27)';
    }

    function example_click()
    {
        in_div.value = window[document.querySelector('#examples').value].trim();
        try_compile();
    }

    function try_compile()
    {
        try {
            if (compile())
                ok_state();
            else
                wip_state();
        } catch (e)
        {
            error_state();
        }
    }

    function in_keypress(args) {
        //window.setTimeout(() => console.log(a, b, c, d), 1000);
        //if (args.code == "Enter")
        if (args.inputType == "insertLineBreak")
        {
            if (in_div.selectionEnd != in_div.selectionStart)
                return;
            let a = in_div.selectionStart;
            let line_end = in_div.value.indexOf('\n', a);
            if (line_end == -1)
                line_end = in_div.value.length;
            if ( in_div.value.substring(a, line_end).trim() != "" )
                return;

            let line_start;
            for (line_start = a - 1; line_start >= 0; --line_start)
            {
                if (in_div.value[line_start] == '\n')
                {
                    break;
                }
            }
            ++line_start;

            let cline = in_div.value.substring(line_start, a);
            let indent = 0;
            for (let i = 0; i < cline.length; ++i)
            {
                if (cline[i] == '|') ++indent;
                else {
                    if (cline[i].toString().trim() == '')
                        continue;
                    if (cline[i] == 'L') {
                        ++indent;
                    }
                    break;
                }
            }
            console.log(cline, indent, line_start, line_end);


            window.setTimeout(() => {
                in_div.value = in_div.value.substring(0, a) + "\n" + '|'.repeat(indent) + " " + '' + in_div.value.substring(line_end + 1);
                console.log(in_div.value );
                in_div.selectionStart = in_div.selectionEnd = a + 2 + indent;
            }, 20);
        }
    }

    window.addEventListener('load', () => {
        example_click();
        in_div.addEventListener('beforeinput', in_keypress, true);
    });

</script>

<script src="index.js"></script>
</body>
</html>
